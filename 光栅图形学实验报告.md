## 光栅图形学实验报告

​																				王焱 计73 

#### 一、实现的功能及成果展示

​	本次实验，我选择实现的是Bresenham画线、四联通区域填充、边沿抗锯齿，另外为了图形的完整美观，添加了中点画圆。主要分为以下几个函数：

```c++
void bresenham(Mat im,Point p0,Point p1, int color)
void polygon(Mat im,Point *p,int n,int color)
void fill(Mat im, Point s, int boundarycolor, int newcolor)
void AApolygon(Mat im, Point *p,int n,int boundarycolor,int innercolor)
void midPointCircle(Mat im, int r, uchar color)
```

​	其中`bresenham`函数实现的是改进的Bresenham算法，避免小数与除法，从`p0`点到`p1`点画一条线。`polygon`函数实现的是多边形的绘制，具体方法是将一个点集依次首尾相连，调用`bresenham`画出多边形的边界。`fill`函数实现了边界表示的四联通区域填充算法，使用循环加栈结构，替代了递归算法。`AApolygon`函数是对一个已经进行了颜色填充的多边形，进行边缘抗锯齿。`midPointCircle`实现的是基本的中点画圆算法。

<img src="C:\Users\焱\Desktop\grayim.png" style="zoom:50%" /><img src="C:\Users\焱\Desktop\局部.png"/>



#### 二、关键代码分析

​	在实现画线算法时，对原有的Bresenham算法，做e'=2\*e*dx的替换，以消除小数和除法。另外对于两个点作为参数，要判断其位置关系较为复杂，但可以大致分为两个方面，即确定以谁为增量和p0到p1的的伸展方向。

```c++
int ux = dx > 0 ? 1 : -1;//x伸展方向
int uy = dy > 0 ? 1 : -1;//y伸展方向
if (dx > dy)
{//以x为增量方向计算
    e = -dx;
    do{
        im.at<uchar>(y, x) = color;
        x += ux;//
        e = e + 2 * dy;
        if (e >= 0)
        {
            y += uy;//
            e = e - 2 * dx;
        }
    } while (x != p1.x);
}
else
{//以y为增量方向计算
 	//类似
}
```

​	`fill`函数中使用循环加栈结构，首先将种子点入栈，每次取出栈顶元素，若符合不是边界并且未被赋新值的条件，对其赋值，并将当前像素点的上下左右四个方向像素点入栈，循环直到栈空。

```c++
while (!p.empty())
{
    point = p.top(); p.pop();
    color = im.at<uchar>(point);
    if (color != newcolor && color != boundarycolor)
    {
        im.at<uchar>(point) = newcolor;
        p.push(Point(point.x, point.y + 1));//上方
        //下、左、右
    }
}
```

​	多边形边缘抗锯齿，由于多边形已经填充了颜色，所以在对其边缘采用每次绘制两个像素的快速抗锯齿方法时，要判断里外，只对外面进行绘制。

```c++
if (q == uy)
    im.at<uchar>(y, x) = innercolor + co * e;
else im.at<uchar>(y + uy, x) = 255 - co * e;
```

#### 三、小结

​	本次实验中，主要遇到了两个问题。在实现区域填充时，一开始我使用的是书上的递归实现的方法，但是实际上会导致栈溢出，所以我改为了循环加栈结构来实现这个功能。另外抗锯齿时，想直接用一个AABresenham抗锯齿的线来重绘多边形边缘，但是忽略了多边形内部颜色这个问题，后来改进方法就是画抗锯齿的边缘线时判断内外，边缘线只对外抗锯齿。

​	通过本次光栅图形学实验，我学会了一些光栅图形学的基本算法，也初步了解了OpenCV的使用，收获颇丰。